import { join } from 'node:path';
import { existsSync, unlinkSync, writeFileSync } from 'node:fs';
import {
  Paths,
  log,
  colors,
  User,
  Username,
  YamlUserRepository,
} from '@minecraft-docker/shared';
import { getContainer } from '../../infrastructure/index.js';
import {
  AdminConfigManager,
  type ApiAccessMode,
} from '../../lib/admin-config.js';
import { Pm2ServiceManagerAdapter } from '../../infrastructure/adapters/Pm2ServiceManagerAdapter.js';
import {
  checkPm2Installation,
  ECOSYSTEM_CONFIG_FILE,
  PM2_SERVICE_NAMES,
  resolveServiceScriptPaths,
} from '../../lib/pm2-utils.js';

/**
 * Console init command options
 */
export interface ConsoleInitOptions {
  root?: string;
  force?: boolean;
  apiPort?: number;
  consolePort?: number;
}

// Backward compatibility alias
export type AdminInitOptions = ConsoleInitOptions;

/**
 * Minimum required Node.js version
 */
const MIN_NODE_VERSION = 18;

/**
 * Check Node.js version meets requirements
 * @returns Object with version check result
 */
export function checkNodeVersion(): {
  valid: boolean;
  version: string;
  required: number;
} {
  const version = process.version.replace('v', '');
  const majorVersion = parseInt(version.split('.')[0] ?? '0', 10);

  return {
    valid: majorVersion >= MIN_NODE_VERSION,
    version,
    required: MIN_NODE_VERSION,
  };
}

/**
 * Delete admin images (legacy - now a no-op for backward compatibility)
 * @deprecated Use PM2 process management instead
 */
export function deleteAdminImages(): {
  success: boolean;
  deleted: string[];
  errors: string[];
} {
  // In PM2 mode, we don't use Docker images
  // This function is kept for backward compatibility
  return {
    success: true,
    deleted: [],
    errors: [],
  };
}

/**
 * Stop admin services using PM2
 */
async function stopAdminServices(paths: Paths): Promise<boolean> {
  const pm2Adapter = new Pm2ServiceManagerAdapter(paths);

  try {
    // Check if services exist and stop them
    for (const serviceName of [PM2_SERVICE_NAMES.API, PM2_SERVICE_NAMES.CONSOLE]) {
      const exists = await pm2Adapter.exists(serviceName);
      if (exists) {
        await pm2Adapter.delete(serviceName);
      }
    }
    return true;
  } catch {
    return false;
  } finally {
    pm2Adapter.disconnect();
  }
}

/**
 * Generate ecosystem.config.cjs content
 * @param apiPort - API server port
 * @param consolePort - Console server port
 * @param apiScriptPath - Absolute path to API script
 * @param consoleScriptPath - Absolute path to console script
 * @param isDevelopment - Whether we're in development mode
 */
function generateEcosystemConfig(
  apiPort: number,
  consolePort: number,
  apiScriptPath: string,
  consoleScriptPath: string,
  isDevelopment: boolean,
  nextAuthSecret: string
): string {
  const modeComment = isDevelopment
    ? '// NOTE: Development mode - using workspace paths'
    : '// NOTE: Production mode - using node_modules paths';

  return `// ecosystem.config.cjs
// =============================================================================
// PM2 Ecosystem Configuration for Minecraft Admin Service
// =============================================================================
// This file is auto-generated by 'mcctl console init' command.
// It configures PM2 to run mcctl-api and mcctl-console services.
//
// Usage:
//   pm2 start ecosystem.config.cjs     # Start all services
//   pm2 stop all                       # Stop all services
//   pm2 restart all                    # Restart all services
//   pm2 logs                           # View logs
//   pm2 status                         # Check status
//
// Installation:
//   npm install -g pm2
//   pm2 startup                        # Configure auto-start on boot
//   pm2 save                           # Save current process list
// =============================================================================
${modeComment}

module.exports = {
  apps: [
    {
      name: 'mcctl-api',
      script: '${apiScriptPath}',
      cwd: process.env.MCCTL_ROOT || '.',
      env: {
        NODE_ENV: '${isDevelopment ? 'development' : 'production'}',
        PORT: ${apiPort},
        HOST: '0.0.0.0',
        MCCTL_ROOT: process.env.MCCTL_ROOT || '.',
      },
      instances: 1,
      exec_mode: 'fork',
      watch: false,
      autorestart: true,
      max_memory_restart: '500M',
    },
    {
      name: 'mcctl-console',
      script: '${consoleScriptPath}',
      cwd: process.env.MCCTL_ROOT || '.',
      env: {
        NODE_ENV: '${isDevelopment ? 'development' : 'production'}',
        PORT: ${consolePort},
        HOSTNAME: '0.0.0.0',
        MCCTL_API_URL: 'http://localhost:${apiPort}',
        MCCTL_ROOT: process.env.MCCTL_ROOT || '.',
        NEXTAUTH_SECRET: '${nextAuthSecret}',
        NEXTAUTH_URL: 'http://localhost:${consolePort}',
      },
      instances: 1,
      exec_mode: 'fork',
      watch: false,
      autorestart: true,
      max_memory_restart: '500M',
    },
  ],
};
`;
}

/**
 * Cleanup existing configuration and services
 * Called when --force flag is used or user confirms reinitialize
 */
async function cleanupExistingConfig(
  paths: Paths,
  configManager: AdminConfigManager,
  prompt: ReturnType<typeof getContainer>['promptPort']
): Promise<boolean> {
  const spinner = prompt.spinner();

  // Step 1: Stop PM2 services
  spinner.start('Stopping console services...');
  const stopResult = await stopAdminServices(paths);
  if (!stopResult) {
    spinner.stop('Warning: Failed to stop some services');
  } else {
    spinner.stop('Console services stopped');
  }

  // Step 2: Delete config files
  spinner.start('Cleaning up configuration files...');
  const filesToDelete = [
    configManager.path, // .mcctl-admin.yml
    join(paths.root, 'users.yaml'),
    join(paths.platform, ECOSYSTEM_CONFIG_FILE), // ecosystem.config.cjs
  ];

  for (const file of filesToDelete) {
    if (existsSync(file)) {
      try {
        unlinkSync(file);
      } catch {
        // Ignore errors
      }
    }
  }
  spinner.stop('Configuration files cleaned up');

  return true;
}

/**
 * Execute console init command
 *
 * Interactive flow:
 * 1. Check Node.js version (>= 18)
 * 2. Check PM2 installation
 * 3. Check if already initialized
 * 4. If exists: prompt for reinitialize confirmation (unless --force)
 * 5. Cleanup existing config if reinitializing
 * 6. Prompt for admin username
 * 7. Prompt for admin password (with confirmation)
 * 8. Prompt for API access mode
 * 9. Generate API key if needed
 * 10. Generate ecosystem.config.cjs
 * 11. Save configuration and user
 */
export async function consoleInitCommand(
  options: ConsoleInitOptions
): Promise<number> {
  // Check Node.js version first
  const nodeCheck = checkNodeVersion();
  if (!nodeCheck.valid) {
    log.error(
      `Node.js version ${nodeCheck.version} is not supported. Minimum required: v${nodeCheck.required}`
    );
    log.info('Please upgrade Node.js: https://nodejs.org/');
    return 1;
  }

  // Check PM2 installation
  const pm2Check = checkPm2Installation();
  if (!pm2Check.installed) {
    log.error('PM2 is not installed.');
    log.info('Install PM2 globally with: npm install -g pm2');
    return 1;
  }

  const paths = new Paths(options.root);

  // Check if platform is initialized
  if (!paths.isInitialized()) {
    log.error('Platform not initialized. Run: mcctl init');
    return 1;
  }

  const container = getContainer({ rootDir: options.root });
  const prompt = container.promptPort;
  const configManager = new AdminConfigManager(options.root);

  // Check if already initialized
  if (configManager.isInitialized()) {
    const existingConfig = await configManager.load();

    if (existingConfig && !options.force) {
      // Show existing config info
      log.warn('Console Service is already initialized');
      console.log(`  Config: ${colors.cyan(configManager.path)}`);
      console.log(
        `  Initialized: ${colors.dim(existingConfig.initialized_at)}`
      );
      console.log('');

      // Prompt for reinitialize
      try {
        const shouldReinitialize = await prompt.confirm({
          message:
            'Existing configuration found. Reinitialize? (This will delete all settings and stop services)',
          initialValue: false,
        });

        if (prompt.isCancel(shouldReinitialize) || !shouldReinitialize) {
          console.log('');
          console.log('  To reinitialize with --force, use:');
          console.log(`    ${colors.dim('mcctl console init --force')}`);
          console.log('');
          return 0;
        }
      } catch (error) {
        if (prompt.isCancel(error)) {
          return 0;
        }
        throw error;
      }
    }

    // Cleanup existing config (either --force or user confirmed)
    await cleanupExistingConfig(paths, configManager, prompt);
    console.log('');
  }

  try {
    prompt.intro('Initialize Console Service');

    // Show environment info
    console.log(colors.dim(`  Node.js: v${nodeCheck.version}`));
    console.log(colors.dim(`  PM2: ${pm2Check.version ?? 'installed'}`));
    console.log('');

    // Step 1: Admin username
    const username = await prompt.text({
      message: 'Admin username?',
      placeholder: 'admin',
      initialValue: 'admin',
      validate: (value) => {
        try {
          Username.create(value);
          return undefined;
        } catch (error) {
          return error instanceof Error
            ? error.message
            : 'Invalid username format';
        }
      },
    });

    // Step 2: Admin password
    const password = await prompt.password({
      message: 'Admin password?',
      validate: (value) => {
        if (!value || value.length < 8) {
          return 'Password must be at least 8 characters';
        }
        // Check for basic password strength
        if (!/[A-Z]/.test(value)) {
          return 'Password must contain at least one uppercase letter';
        }
        if (!/[a-z]/.test(value)) {
          return 'Password must contain at least one lowercase letter';
        }
        if (!/[0-9]/.test(value)) {
          return 'Password must contain at least one number';
        }
        return undefined;
      },
    });

    // Step 3: Confirm password
    await prompt.password({
      message: 'Confirm password?',
      validate: (value) => {
        if (value !== password) {
          return 'Passwords do not match';
        }
        return undefined;
      },
    });

    // Step 4: API access mode
    const accessMode = await prompt.select<ApiAccessMode>({
      message: 'API access mode?',
      options: [
        {
          value: 'internal' as const,
          label: 'internal',
          hint: 'Local network only (default, most secure)',
        },
        {
          value: 'api-key' as const,
          label: 'api-key',
          hint: 'External access with API key',
        },
        {
          value: 'ip-whitelist' as const,
          label: 'ip-whitelist',
          hint: 'IP-based access control',
        },
        {
          value: 'api-key-ip' as const,
          label: 'api-key-ip',
          hint: 'Both API key and IP required',
        },
        {
          value: 'open' as const,
          label: 'open',
          hint: 'No authentication (development only)',
        },
      ],
      initialValue: 'internal' as const,
    });

    // Step 5: Port configuration
    const DEFAULT_API_PORT = 3001;
    const DEFAULT_CONSOLE_PORT = 3000;

    let apiPort = options.apiPort ?? DEFAULT_API_PORT;
    let consolePort = options.consolePort ?? DEFAULT_CONSOLE_PORT;

    // Only ask for ports if not provided via CLI options
    if (!options.apiPort || !options.consolePort) {
      const customPorts = await prompt.confirm({
        message: 'Configure custom ports?',
        initialValue: false,
      });

      if (customPorts) {
        if (!options.apiPort) {
          const apiPortInput = await prompt.text({
            message: 'API server port?',
            placeholder: String(DEFAULT_API_PORT),
            initialValue: String(DEFAULT_API_PORT),
            validate: (value) => {
              const port = parseInt(value, 10);
              if (isNaN(port) || port < 1 || port > 65535) {
                return 'Port must be a number between 1 and 65535';
              }
              return undefined;
            },
          });
          apiPort = parseInt(apiPortInput, 10);
        }

        if (!options.consolePort) {
          const consolePortInput = await prompt.text({
            message: 'Console server port?',
            placeholder: String(DEFAULT_CONSOLE_PORT),
            initialValue: String(DEFAULT_CONSOLE_PORT),
            validate: (value) => {
              const port = parseInt(value, 10);
              if (isNaN(port) || port < 1 || port > 65535) {
                return 'Port must be a number between 1 and 65535';
              }
              if (port === apiPort) {
                return 'Console port must be different from API port';
              }
              return undefined;
            },
          });
          consolePort = parseInt(consolePortInput, 10);
        }
      }
    }

    // Step 6: Generate API key if needed
    let apiKey: string | null = null;
    if (accessMode === 'api-key' || accessMode === 'api-key-ip') {
      const spinner = prompt.spinner();
      spinner.start('Generating API key...');

      apiKey = AdminConfigManager.generateApiKey();

      spinner.stop('API key generated');
    }

    // Step 7: Prompt for allowed IPs if needed
    let allowedIps: string[] = [];
    if (accessMode === 'ip-whitelist' || accessMode === 'api-key-ip') {
      const ipsInput = await prompt.text({
        message: 'Allowed IPs (comma-separated)?',
        placeholder: '127.0.0.1, 192.168.1.0/24',
        validate: (value) => {
          if (!value.trim()) {
            return 'At least one IP or CIDR range is required';
          }
          // Basic IP/CIDR validation
          const ips = value.split(',').map((ip) => ip.trim());
          for (const ip of ips) {
            // Simple validation - allows IP or CIDR notation
            if (
              !/^(\d{1,3}\.){3}\d{1,3}(\/\d{1,2})?$/.test(ip) &&
              ip !== 'localhost'
            ) {
              return `Invalid IP format: ${ip}`;
            }
          }
          return undefined;
        },
      });

      allowedIps = ipsInput.split(',').map((ip) => ip.trim());
    }

    // Step 8: Show warning for open mode
    if (accessMode === 'open') {
      prompt.warn(
        'WARNING: Open mode has no authentication. Use only for local development!'
      );
      const proceed = await prompt.confirm({
        message: 'Are you sure you want to use open mode?',
        initialValue: false,
      });
      if (!proceed) {
        prompt.info('Cancelled. Please run again to choose a different mode.');
        return 0;
      }
    }

    // Step 9: Save user to YAML
    const spinner = prompt.spinner();
    spinner.start('Creating admin user...');

    const usersPath = join(paths.root, 'users.yaml');
    const userRepo = new YamlUserRepository(usersPath);

    // Check if user already exists
    const usernameVO = Username.create(username);
    const existingUser = await userRepo.findByUsername(usernameVO);

    if (existingUser && !options.force) {
      spinner.stop('');
      log.error(`User '${username}' already exists`);
      console.log('  To overwrite, use: mcctl console init --force');
      return 1;
    }

    // Hash password and create user
    const passwordHash = await userRepo.hashPassword(password);
    const adminUser = User.createAdmin(usernameVO, passwordHash);

    // If user exists and force is true, delete the old one first
    if (existingUser && options.force) {
      await userRepo.delete(existingUser.id);
    }

    await userRepo.save(adminUser);
    spinner.stop('Admin user created');

    // Step 10: Generate ecosystem.config.cjs
    spinner.start('Resolving service script paths...');

    // Resolve script paths (development vs production)
    const scriptPaths = resolveServiceScriptPaths(paths.root);

    if (scriptPaths.isDevelopment) {
      spinner.stop('Using development workspace paths');
      console.log(colors.dim(`    API: ${scriptPaths.api}`));
      console.log(colors.dim(`    Console: ${scriptPaths.console}`));
    } else {
      spinner.stop('Using production node_modules paths');
    }

    spinner.start('Generating PM2 ecosystem config...');

    // Generate NextAuth secret for session encryption
    const nextAuthSecret = AdminConfigManager.generateApiKey();

    const ecosystemPath = join(paths.platform, ECOSYSTEM_CONFIG_FILE);
    const ecosystemContent = generateEcosystemConfig(
      apiPort,
      consolePort,
      scriptPaths.api,
      scriptPaths.console,
      scriptPaths.isDevelopment,
      nextAuthSecret
    );
    writeFileSync(ecosystemPath, ecosystemContent, 'utf-8');

    spinner.stop('PM2 ecosystem config generated');

    // Step 11: Save configuration
    spinner.start('Saving configuration...');

    const config = await configManager.create({
      accessMode,
      apiKey,
      allowedIps,
      apiPort,
      consolePort,
    });

    spinner.stop('Configuration saved');

    // Step 12: Display summary
    console.log('');
    prompt.success('Console Service initialized!');

    console.log('');
    console.log(colors.cyan('  Configuration:'));
    console.log(`    Config file: ${colors.dim(configManager.path)}`);
    console.log(`    Users file:  ${colors.dim(usersPath)}`);
    console.log(`    PM2 config:  ${colors.dim(ecosystemPath)}`);
    console.log(`    Access mode: ${colors.bold(accessMode)}`);

    if (apiKey) {
      console.log('');
      console.log(colors.yellow('  API Key (save this, shown only once):'));
      console.log(`    ${colors.bold(apiKey)}`);
    }

    if (allowedIps.length > 0) {
      console.log('');
      console.log(colors.cyan('  Allowed IPs:'));
      for (const ip of allowedIps) {
        console.log(`    - ${ip}`);
      }
    }

    console.log('');
    console.log(colors.cyan('  Endpoints:'));
    console.log(
      `    Console: ${colors.bold(`http://localhost:${config.console.port}`)}`
    );
    console.log(
      `    API:     ${colors.bold(`http://localhost:${config.api.port}`)}`
    );

    console.log('');
    console.log(colors.dim('  Next steps:'));
    console.log(
      colors.dim('    1. Start the console service: mcctl console service start')
    );
    console.log(colors.dim('    2. Access the console in your browser'));
    console.log('');

    return 0;
  } catch (error) {
    // Check if user cancelled
    if (prompt.isCancel(error)) {
      return 0;
    }

    const message = error instanceof Error ? error.message : String(error);
    log.error(message);
    return 1;
  }
}

// Backward compatibility alias
export const adminInitCommand = consoleInitCommand;

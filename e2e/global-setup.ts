import { FullConfig } from '@playwright/test';
import { spawn, spawnSync, execSync } from 'child_process';
import { existsSync } from 'fs';
import { join } from 'path';

/**
 * Global setup for E2E tests.
 *
 * This runs once before all tests. Use it for:
 * - Starting PM2-managed services (mcctl-api + mcctl-console)
 * - Waiting for services to be ready
 * - Creating test users if needed
 */
async function globalSetup(config: FullConfig): Promise<void> {
  const baseURL = config.projects[0]?.use?.baseURL || 'http://localhost:3000';
  const apiURL = process.env.E2E_API_URL || 'http://localhost:5000';

  console.log('[Global Setup] Starting E2E test setup...');
  console.log(`[Global Setup] Console URL: ${baseURL}`);
  console.log(`[Global Setup] API URL: ${apiURL}`);

  // Start services via PM2 if not running
  if (!process.env.E2E_SKIP_SERVICE_START) {
    await startServicesViaPm2();
  } else {
    console.log('[Global Setup] Skipping service start (E2E_SKIP_SERVICE_START is set)');
  }

  // Wait for services to be ready
  await waitForService(baseURL, 'Console');
  await waitForService(`${apiURL}/health`, 'API');

  console.log('[Global Setup] All services are ready');
}

/**
 * Start services via PM2.
 * Uses the ecosystem.config.cjs generated by 'mcctl console init'.
 */
async function startServicesViaPm2(): Promise<void> {
  // Find the platform directory (relative to e2e/)
  const platformDir = findPlatformDir();

  if (!platformDir) {
    console.log('[Global Setup] Platform directory not found, skipping PM2 start');
    console.log('[Global Setup] Assuming services are already running externally');
    return;
  }

  const ecosystemConfigPath = join(platformDir, 'ecosystem.config.cjs');

  // Check if ecosystem config exists
  if (!existsSync(ecosystemConfigPath)) {
    console.log(`[Global Setup] ecosystem.config.cjs not found at ${ecosystemConfigPath}`);
    console.log('[Global Setup] Run "mcctl console init" to generate the config');
    console.log('[Global Setup] Assuming services are already running externally');
    return;
  }

  // Check if PM2 is available
  const pm2Available = checkPm2Available();
  if (!pm2Available) {
    console.log('[Global Setup] PM2 not found. Please install PM2 globally:');
    console.log('[Global Setup]   npm install -g pm2');
    console.log('[Global Setup] Assuming services are already running externally');
    return;
  }

  console.log(`[Global Setup] Starting services via PM2...`);
  console.log(`[Global Setup] Using ecosystem config: ${ecosystemConfigPath}`);

  try {
    // Check if services are already running
    const statusResult = spawnSync('pm2', ['jlist'], {
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe'],
    });

    if (statusResult.status === 0 && statusResult.stdout) {
      try {
        const processes = JSON.parse(statusResult.stdout);
        const apiRunning = processes.some((p: { name: string; pm2_env?: { status?: string } }) =>
          p.name === 'mcctl-api' && p.pm2_env?.status === 'online'
        );
        const consoleRunning = processes.some((p: { name: string; pm2_env?: { status?: string } }) =>
          p.name === 'mcctl-console' && p.pm2_env?.status === 'online'
        );

        if (apiRunning && consoleRunning) {
          console.log('[Global Setup] Services already running via PM2');
          return;
        }
      } catch {
        // Continue to start services
      }
    }

    // Start services using PM2
    const startResult = spawnSync('pm2', ['start', ecosystemConfigPath], {
      cwd: platformDir,
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe'],
      env: {
        ...process.env,
        MCCTL_ROOT: platformDir,
      },
    });

    if (startResult.status !== 0) {
      console.error('[Global Setup] PM2 start failed:', startResult.stderr);
      console.log('[Global Setup] Continuing anyway, services might be running externally');
    } else {
      console.log('[Global Setup] PM2 services started successfully');

      // Give services a moment to initialize
      await new Promise((resolve) => setTimeout(resolve, 3000));
    }
  } catch (error) {
    console.error('[Global Setup] Error starting PM2 services:', error);
    console.log('[Global Setup] Continuing anyway, services might be running externally');
  }
}

/**
 * Find the platform directory.
 */
function findPlatformDir(): string | null {
  // Try common locations
  const possiblePaths = [
    join(process.cwd(), '..', 'platform'),           // From e2e/ directory
    join(process.cwd(), 'platform'),                  // From project root
    join(__dirname, '..', 'platform'),               // Relative to this file
    process.env.MCCTL_ROOT || '',                     // From environment
  ];

  for (const p of possiblePaths) {
    if (p && existsSync(p)) {
      // Verify it's actually the platform directory by checking for docker-compose.yml
      if (existsSync(join(p, 'docker-compose.yml')) || existsSync(join(p, 'services'))) {
        return p;
      }
    }
  }

  return null;
}

/**
 * Check if PM2 is available.
 */
function checkPm2Available(): boolean {
  try {
    const result = spawnSync('which', ['pm2'], {
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe'],
    });
    return result.status === 0;
  } catch {
    return false;
  }
}

/**
 * Wait for a service to be ready by polling its URL.
 */
async function waitForService(
  url: string,
  serviceName: string,
  maxRetries = 30,
  retryInterval = 2000
): Promise<void> {
  console.log(`[Global Setup] Waiting for ${serviceName} at ${url}...`);

  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, {
        method: 'GET',
        signal: AbortSignal.timeout(5000),
      });

      if (response.ok) {
        console.log(`[Global Setup] ${serviceName} is ready (status: ${response.status})`);
        return;
      }
    } catch {
      // Service not ready yet, continue polling
    }

    if (i < maxRetries - 1) {
      console.log(`[Global Setup] ${serviceName} not ready, retrying in ${retryInterval / 1000}s... (${i + 1}/${maxRetries})`);
      await new Promise((resolve) => setTimeout(resolve, retryInterval));
    }
  }

  throw new Error(`[Global Setup] ${serviceName} at ${url} did not become ready within timeout`);
}

export default globalSetup;
